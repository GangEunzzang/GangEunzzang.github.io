---
title: 동서싱 이슈 해결 방법
date: 2024-03-19 23:30:00 +09:00
categories: [spring]
tags:
  [
    java,
    트랜잭션,
    synchronized,
    Spring,
    redis,
    docker
  ]
---

* * *

해당 글은 [재고시스템으로 알아보는 동시성 이슈 해결 방법](https://www.inflearn.com/course/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4%EC%8A%88-%EC%9E%AC%EA%B3%A0%EC%8B%9C%EC%8A%A4%ED%85%9C/dashboard) 강의를 정리한 글입니다.

`정리 코드`: [깃허브 링크](https://github.com/GangEunzzang/stock)

`개발 환경`
* Java 17
* Spring boot 3.2.3
* redis 
* docker
* mysql
* jpa
* lombok

<br><br>

## ✅ 동시성 이슈란?
* 동시에 여러 개의 스레드, 프로세스 또는 작업이 공유된 자원에 접근하고 수정하는 과정에서 발생할 수 있는 문제들
* 여러 작업이 동시에 실행되고 동시에 동일한 자원에 접근하거나 수정하려고 할 때 발생되는 이슈

<br>

### 📌 동서싱 이슈로 발생되는 문제
* `경쟁상태(Race Condition)`: 여러 개의 스레드나 프로세스가 동시에 공유된 자원에 접근하고 수정할 때, 실행 순서나 타이밍 등에 따라 예기치 않은 결과가 발생
* `교착상태(DeadLock)`: 두 개 이상의 작업이 서로 상대방이 가진 자원을 기다리면서 무한히 대기하는 상태
* `일관성 문제(Consistency Issue)`: 동시에 여러개의 작업이 데이터를 수정하거나 읽고 쓰는 경우, 데이터 일관성이 깨질 수 있음
* `병목 현상(Bottleneck)`: 특정 자원에 대한 동시 접근이 많아져 병목현상 발생

<br><Br>

##  ✅ 재고시스템 기본 코드

### 📌 Stock

```java
@Getter
@NoArgsConstructor
@Entity
public class Stock {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;

  private Long productId;

  private Long quantity;

  @Version
  private Long version;

  public Stock (long productId, long quantity) {
    this.productId = productId;
    this.quantity = quantity;
  }

  public void decrease(Long quantity) {
    if (this.quantity - quantity < 0) {
      throw new RuntimeException("재고는 0개미만이 될 수 없습니다.");
    }

    this.quantity -= quantity;
  }
}

```

<br>

### 📌 StockRepository
```java
public interface StockRepository extends JpaRepository<Stock, Long> {
}
```



<br>

### 📌 StockService
```java
@RequiredArgsConstructor
@Service
public class StockService {

    private final StockRepository stockRepository;

    @Transactional
    public void decrease(Long id, Long quantity) {
        Stock stock = stockRepository.findById(id).orElseThrow();
        stock.decrease(quantity);

        stockRepository.saveAndFlush(stock);
    }
}
```
<br>

### 📌 StockServiceTest
```java
@SpringBootTest
class StockServiceTest {

    @Autowired
    private StockService stockService;

    @Autowired
    private StockRepository stockRepository;

    @BeforeEach
    public void dataInsert() {
        stockRepository.saveAndFlush(new Stock(1L, 100L));
    }

    @AfterEach
    public void dataDelete() {
        stockRepository.deleteAll();
    }


    @Test
    void 재고감소() throws Exception {
        stockService.decrease(1L, 1L);

        Stock stock = stockRepository.findById(1L).orElseThrow();

        assertThat(99L).isEqualTo(stock.getQuantity());
    }


    @Test
    void 동시에_100개요청_재고감소() throws Exception {
        //given
        int threadCount = 100;
        ExecutorService executorService = Executors.newFixedThreadPool(32);
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            executorService.submit(() -> {
                try {
                    stockService.decrease(1L, 1L);
                }
                finally {
                    latch.countDown();
                }
            });
        }
        latch.await();

        Stock stock = stockRepository.findById(1L).orElseThrow();
        assertThat(stock.getQuantity()).isZero();
    }

}
```

<br>

위 테스트 코드 중 `동시에_100개요청_재고감소` 테스트 실행 결과입니다.

![stockestfail.png](..%2F..%2Fassets%2Fimg%2FSpring%2Fstockestfail.png)

`테스트 실패 ..!` 

아래 여러 예제를 통해 동시성 이슈를 해결해 보겠습니다.

<br><br>


## ✅ 동서싱 이슈 해결

### 📌 Java - synchronized

```java
public synchronized void decrease(Long id, Long quantity) {
  Stock stock = stockRepository.findById(id).orElseThrow();
  stock.decrease(quantity);

  stockRepository.saveAndFlush(stock);
}
```

* 메서드에 고유락을 걸어 하나의 스레드만 접근 가능하게 해준다.
* `멀티스레드 환경에서 스레드간 데이터 동기화`를 시켜주기 위해 자바에서 제공하는 키워드

#### 문제점
* `synchronized`는 하나의 프로세스 안에서만 보장이 된다
* 서버가 1대일 때는 정상 동작하지만 서버가 2대 이상일 경우 동기화가 불가능하다.
* @Transactional 과 동시에 사용할 수 없습니다.
  -> 실제 `commit` 나가는 시점보다 빠르게 다음 스레드가 메서드 실행하기 때문에 데이티 불일치 문제 발생

<br>


### 📌 Database(Mysql) - Pessimistic Lock(비관적 락)
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("select s from Stock s where s.id = :id")
Stock findByIdWithPessimisticLock(Long id);
}
```

* 실제 쿼리에 Lock을 걸어 정합성을 맞추는 방법
* `exclusive lock(베타적 잠금)`을 걸게되면 다른 트랜잭션에서는 lock이 해제되기 전에 데이터를 가져갈 수 없음
* lock의 범위를 최소한 해야한다.

#### 문제점
* 데드락이 걸릴 수 있음
* 동시 처리 성능 저하 발생

<br>


### 📌 Database(Mysql) - Optimistic Lock(낙관적 락)
```java

// Stock 클래스에 추가
@Version
private Long version; 

// Repository
@Lock(LockModeType.OPTIMISTIC)
@Query("select s from Stock s where s.id = :id")
Stock findByIdWithOptimisticLock(Long id);
}

```

* Entity에 version 컬럼 추가 및 충돌 발생시 처리 로직을 직접 구현해주는 방식
* 실제로 Lock을 걸지않고 version 값을 이용하여 정합성을 맞추는 방법
* 충돌이 나지 않는다는 가정하에, 별도의 락을 잡지 않으므로 비관적 락보단 성능이 좋음

#### 과정
1. Server1이 version1 임을 조건절에 명시하면서 업데이트 쿼리를 날림
2. version1 값이 업데이트 되어 version2가 됨
3. server2가 version1로 업데이트를 시도하면 버전이 맞지 않아 실패함

#### 문제점
* 업데이트가 실패했을 때, 재시도 로직을 개발자가 구현해 줘야함
* 충돌이 빈번하게 일어나면 오히려 성능이 안좋음

<br>


### 📌 Database(Mysql) - Named Lock

```java
// Repository
@Query(value = "select get_lock(:key, 3000)", nativeQuery = true)
void getLock(String key);

@Query(value = "select release_lock(:key)", nativeQuery = true)
void releaseLock(String key);


// service
@Transactional
public void decrease(Long id, Long quantity) {
  try {
    lockRepository.getLock(id.toString());
    stockService.decrease(id, quantity);
  } finally {
    lockRepository.releaseLock(id.toString());
  }
}
```

* 이름을 가진 `metadata Lock`이다.
* 락을 획득 후, 해지될 때 까지 다른 세션은 이 락을 획득할 수 없음
* 트랜잭션이 종료될 때 락이 자동으로 해지되기 않기 때문에, 별도로 해주해주거나 선점시간이 끝나야 해지됨
* Mysql에서는 `getLock()` 락 획득, `releaseLock()` 락 해제 명령어 입니다.
* `Pessimistic Lock` 은 time out을 구현하기 힘들지만, `Named Lock`은 손쉽게 명시할 수 있음

#### 문제점
* 실제 서비스에서는 커넥션풀이 부족해질 수 있기때문에 DataSource 분리 해야한다.

<br>


### 📌 Redis - Lettuce



종료 요청시 아래의 `shutDownGracefully` 메서드가 호출됩니다. 
```java
public void shutDownGracefully(GracefulShutdownCallback callback) {
        if (this.gracefulShutdown == null) {
            callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE);
        } else {
            this.gracefulShutdown.shutDownGracefully(callback);
        }
    }
```



그리고 `GracefulShutdown`의 `shutDownGracefully` 메소드를 호출합니다.
```java
void shutDownGracefully(GracefulShutdownCallback callback) {
        logger.info("Commencing graceful shutdown. Waiting for active requests to complete");
        (new Thread(() -> {
            this.doShutdown(callback);
        }, "tomcat-shutdown")).start();
    }

    private void doShutdown(GracefulShutdownCallback callback) {
        List<Connector> connectors = this.getConnectors();
        connectors.forEach(this::close);

        try {
            Container[] var3 = this.tomcat.getEngine().findChildren();
            int var4 = var3.length;

            for(int var5 = 0; var5 < var4; ++var5) {
                Container host = var3[var5];
                Container[] var7 = host.findChildren();
                int var8 = var7.length;

                for(int var9 = 0; var9 < var8; ++var9) {
                    Container context = var7[var9];

                    while(this.isActive(context)) {
                        if (this.aborted) {
                            logger.info("Graceful shutdown aborted with one or more requests still active");
                            callback.shutdownComplete(GracefulShutdownResult.REQUESTS_ACTIVE);
                            return;
                        }

                        Thread.sleep(50L);
                    }
                }
            }
        } catch (InterruptedException var11) {
            Thread.currentThread().interrupt();
        }

        logger.info("Graceful shutdown complete");
        callback.shutdownComplete(GracefulShutdownResult.IDLE);
    }
```

먼저, `doShutdown 메서드에서 connector들을 닫음으로써 새로운 요청들을 받지 않도록` 합니다.

`doShutdown 메서드 내부 while문에서 isActive라는 메서드를 통해 현재 처리중인 요청이 있는지 확인`하고   
존재하면 루프에서 50ms씩 기다리면서 지속적으로 완료되지 않은 요청에 대한 확인을 합니다.



