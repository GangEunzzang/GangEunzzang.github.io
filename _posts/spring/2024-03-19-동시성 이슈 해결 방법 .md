---
title: 동서싱 이슈 해결 방법
date: 2024-03-19 23:30:00 +09:00
categories: [spring]
tags:
  [
    java,
    트랜잭션,
    synchronized,
    Spring,
    redis,
    docker
  ]
---

* * *

해당 글은 [재고시스템으로 알아보는 동시성 이슈 해결 방법](https://www.inflearn.com/course/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4%EC%8A%88-%EC%9E%AC%EA%B3%A0%EC%8B%9C%EC%8A%A4%ED%85%9C/dashboard) 강의를 정리한 글입니다.

정리 코드 : [깃허브 링크](https://github.com/GangEunzzang/stock)

개발 환경
* Java 17
* Spring boot 3.2.3
* redis 
* docker
* mysql
* jpa
* lombok

<br><br>

## ✅ 동시성 이슈란?
* 동시에 여러 개의 스레드, 프로세스 또는 작업이 공유된 자원에 접근하고 수정하는 과정에서 발생할 수 있는 문제들
* 여러 작업이 동시에 실행되고 동시에 동일한 자원에 접근하거나 수정하려고 할 때 발생되는 이슈

### 📌 동서싱 이슈로 발생되는 문제
* `경쟁상태(Race Condition)`: 여러 개의 스레드나 프로세스가 동시에 공유된 자원에 접근하고 수정할 때, 실행 순서나 타이밍 등에 따라 예기치 않은 결과가 발생
* `교착상태(DeadLock)`: 두 개 이상의 작업이 서로 상대방이 가진 자원을 기다리면서 무한히 대기하는 상태
* `일관성 문제(Consistency Issue)`: 동시에 여러개의 작업이 데이터를 수정하거나 읽고 쓰는 경우, 데이터 일관성이 깨질 수 있음
* `병목 현상(Bottleneck)`: 특정 자원에 대한 동시 접근이 많아져 병목현상 발생

<br><Br>

##  ✅ 재고시스템 기본 코드

### 📌 Stock

```java
@Getter
@NoArgsConstructor
@Entity
public class Stock {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;

  private Long productId;

  private Long quantity;

  @Version
  private Long version;

  public Stock (long productId, long quantity) {
    this.productId = productId;
    this.quantity = quantity;
  }

  public void decrease(Long quantity) {
    if (this.quantity - quantity < 0) {
      throw new RuntimeException("재고는 0개미만이 될 수 없습니다.");
    }

    this.quantity -= quantity;
  }
}

```

<br>

### 📌 StockRepository
```java
public interface StockRepository extends JpaRepository<Stock, Long> {
}
```



<br>

### 📌 StockService
```java
@RequiredArgsConstructor
@Service
public class StockService {

    private final StockRepository stockRepository;

    @Transactional
    public void decrease(Long id, Long quantity) {
        Stock stock = stockRepository.findById(id).orElseThrow();
        stock.decrease(quantity);

        stockRepository.saveAndFlush(stock);
    }
}
```

## 📌 StockServiceTest
```java
@SpringBootTest
class StockServiceTest {

    @Autowired
    private StockService stockService;

    @Autowired
    private StockRepository stockRepository;

    @BeforeEach
    public void dataInsert() {
        stockRepository.saveAndFlush(new Stock(1L, 100L));
    }

    @AfterEach
    public void dataDelete() {
        stockRepository.deleteAll();
    }


    @Test
    void 재고감소() throws Exception {
        stockService.decrease(1L, 1L);

        Stock stock = stockRepository.findById(1L).orElseThrow();

        assertThat(99L).isEqualTo(stock.getQuantity());
    }


    @Test
    void 동시에_100개요청_재고감소() throws Exception {
        //given
        int threadCount = 100;
        ExecutorService executorService = Executors.newFixedThreadPool(32);
        CountDownLatch latch = new CountDownLatch(threadCount);

        for (int i = 0; i < threadCount; i++) {
            executorService.submit(() -> {
                try {
                    stockService.decrease(1L, 1L);
                }
                finally {
                    latch.countDown();
                }
            });
        }
        latch.await();

        Stock stock = stockRepository.findById(1L).orElseThrow();
        assertThat(stock.getQuantity()).isZero();
    }

}
```


<br>

![stockestfail.png](..%2F..%2Fassets%2Fimg%2FSpring%2Fstockestfail.png)

`테스트 실패 ! ! ! ! ! ! ! ! !` 

위 코드를 기반으로 동작되며 아래 여러 예제를 통해 동시성 이슈를 해결해 보겠습니다.

<br><br>


## ✅ 동서싱 이슈 해결

### 📌 Graceful이 설정된 Tomcat

```java
public class TomcatWebServer implements WebServer {

    private final GracefulShutdown gracefulShutdown;

    public TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) {
        Assert.notNull(tomcat, "Tomcat Server must not be null");
        this.tomcat = tomcat;
        this.autoStart = autoStart;
        this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(tomcat) : null;
        initialize();
    }
}
```
서버 실행시 shutdown 설정값이 graceful이라면 `GracefulShutdown` 객체를 넣어줍니다.

### 📌 종료 과정

종료 요청시 아래의 `shutDownGracefully` 메서드가 호출됩니다. 
```java
public void shutDownGracefully(GracefulShutdownCallback callback) {
        if (this.gracefulShutdown == null) {
            callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE);
        } else {
            this.gracefulShutdown.shutDownGracefully(callback);
        }
    }
```

그리고 `GracefulShutdown`의 `shutDownGracefully` 메소드를 호출합니다.
```java
void shutDownGracefully(GracefulShutdownCallback callback) {
        logger.info("Commencing graceful shutdown. Waiting for active requests to complete");
        (new Thread(() -> {
            this.doShutdown(callback);
        }, "tomcat-shutdown")).start();
    }

    private void doShutdown(GracefulShutdownCallback callback) {
        List<Connector> connectors = this.getConnectors();
        connectors.forEach(this::close);

        try {
            Container[] var3 = this.tomcat.getEngine().findChildren();
            int var4 = var3.length;

            for(int var5 = 0; var5 < var4; ++var5) {
                Container host = var3[var5];
                Container[] var7 = host.findChildren();
                int var8 = var7.length;

                for(int var9 = 0; var9 < var8; ++var9) {
                    Container context = var7[var9];

                    while(this.isActive(context)) {
                        if (this.aborted) {
                            logger.info("Graceful shutdown aborted with one or more requests still active");
                            callback.shutdownComplete(GracefulShutdownResult.REQUESTS_ACTIVE);
                            return;
                        }

                        Thread.sleep(50L);
                    }
                }
            }
        } catch (InterruptedException var11) {
            Thread.currentThread().interrupt();
        }

        logger.info("Graceful shutdown complete");
        callback.shutdownComplete(GracefulShutdownResult.IDLE);
    }
```

먼저, `doShutdown 메서드에서 connector들을 닫음으로써 새로운 요청들을 받지 않도록` 합니다.

`doShutdown 메서드 내부 while문에서 isActive라는 메서드를 통해 현재 처리중인 요청이 있는지 확인`하고   
존재하면 루프에서 50ms씩 기다리면서 지속적으로 완료되지 않은 요청에 대한 확인을 합니다.



