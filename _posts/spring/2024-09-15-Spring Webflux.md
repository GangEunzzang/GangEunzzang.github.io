---
title: Spring WebFlux의 주요 개념, Netty와 Tomcat의 차이 및 실용적 적용
date: 2024-09-15 23:30:00 +09:00
categories: [spring]
tags:
  [
    java,
    spring,
    WebFlux,
    Reactive,
    비동기 프로그래밍,
    성능 최적화,
    Netty,
    Tomcat,
    리액티브 프로그래밍,
    이벤트 루프
  ]
---

---

현대의 웹 애플리케이션은 고성능과 확장성을 필수로 요구하는데, 이를 효과적으로 지원하기 위해 **Spring WebFlux**가 등장했다. WebFlux는 **Spring 5**부터 도입된 리액티브 프로그래밍 기반의 웹 프레임워크로, **비동기** 및 **논블로킹** 방식으로 동작하여 더 많은 요청을 처리할 수 있는 확장성을 제공한다. 이는 전통적인 **Spring MVC**와는 상당히 다른 모델로, 특히 **I/O 바운드 작업**이 많은 환경에서 뛰어난 성능을 발휘한다.

이번 글에서는 **Spring WebFlux**의 주요 개념, **Netty**와 **Tomcat**의 차이, 그리고 **리액티브 프로그래밍**의 핵심 원리와 실무 적용에 대해 구체적으로 알아보자.

<br><br>

## ✅ Spring WebFlux란?

**Spring WebFlux**는 **논블로킹 I/O**와 **비동기 처리**를 기반으로 동작하는 리액티브 웹 프레임워크다. 기존 **Spring MVC**는 요청을 처리할 때 I/O 작업을 대기해야 하므로 **블로킹 방식**으로 동작한다. 반면 WebFlux는 I/O 작업을 비동기 방식으로 처리하여 더 많은 동시 요청을 처리할 수 있다.

WebFlux는 특히 **고성능 API**나 **마이크로서비스**와 같은 대규모 트래픽을 처리하는 환경에서 큰 장점을 제공한다. 그 이유는 바로 **이벤트 기반 아키텍처**와 **논블로킹 I/O**를 통해, 자원을 효율적으로 사용하면서 높은 동시성을 지원하기 때문이다.

<br>

### 📌 WebFlux의 주요 특징

1. **반응형 프로그래밍(Reactive Programming)**: WebFlux는 **Reactive Streams** 사양을 따르며, **Mono**와 **Flux**를 통해 비동기 데이터 흐름을 관리한다.
2. **논블로킹 I/O**: I/O 작업이 블로킹되지 않고 논블로킹 방식으로 처리되어, 많은 요청을 동시에 처리할 수 있는 구조다.
3. **Reactor** 기반: **Reactor** 라이브러리는 WebFlux에서 데이터 스트림을 처리하기 위한 핵심 라이브러리로, 리액티브 프로그래밍의 기본 원칙을 구현한다.
4. **다양한 서버 지원**: WebFlux는 **Netty**를 기본 서버로 사용하지만, **Tomcat**, **Jetty**와 같은 전통적인 서블릿 컨테이너에서도 동작할 수 있다.

<br>

### 📌 리액티브 스트림의 기본 개념

- **Mono**: 0 또는 1개의 데이터 항목을 비동기적으로 처리하는 스트림 객체.
- **Flux**: 0부터 N개의 데이터를 비동기적으로 처리하는 스트림 객체.
- **Backpressure(백프레셔)**: 소비자가 처리할 수 있는 데이터 양을 조절하는 메커니즘으로, 데이터 처리 속도를 맞추기 위해 사용된다.

리액티브 스트림은 비동기적 이벤트 흐름을 다루는 방식으로, 웹 애플리케이션에서 **I/O 작업을 효율적으로 처리**할 수 있게 돕는다. 예를 들어, 대규모 트래픽이 발생하는 상황에서 요청에 대해 동기적으로 처리하지 않고, 비동기적으로 처리하여 서버의 자원을 아끼고, 더 많은 요청을 처리하는 방식이다.

<br><br>

## ✅ Netty와 Tomcat의 차이

**Spring WebFlux**는 기본적으로 **Netty** 서버에서 동작하지만, **Tomcat**에서도 사용할 수 있다. 이 두 서버는 서로 다른 아키텍처와 동작 방식을 가지고 있으며, 특히 **비동기 처리**와 **논블로킹 처리**에서 큰 차이를 보인다.

### 📌 Netty

**Netty**는 자바 기반의 고성능 네트워크 애플리케이션 프레임워크로, **비동기 이벤트 기반** 아키텍처를 사용하여 높은 성능과 확장성을 제공한다. 주로 **비동기** 및 **논블로킹 I/O**를 처리하는데 특화되어 있으며, HTTP뿐만 아니라 TCP, UDP 같은 다양한 네트워크 프로토콜도 지원한다.

- **이벤트 루프(Event Loop)**: Netty는 이벤트 루프를 사용하여 비동기 작업을 처리한다. 이벤트 루프는 네트워크 이벤트나 파일 I/O 이벤트를 감지하고 이를 처리하는 방식으로 동작한다. Netty는 이벤트 루프가 적은 리소스로 다수의 요청을 처리할 수 있게 설계되어 있어, 높은 동시성을 제공한다.
- **성능**: 비동기 방식으로 설계된 Netty는 블로킹 없이 요청을 처리하므로, 더 적은 스레드로 더 많은 트래픽을 처리할 수 있다. 이는 특히 **마이크로서비스**나 **고성능 API** 설계에 매우 유리하다.
- **확장성**: Netty는 적은 스레드로 많은 요청을 처리할 수 있는 **높은 확장성**을 제공하며, 대규모 트래픽을 처리할 때 성능이 급격히 저하되지 않는다.

### 📌 Tomcat

**Tomcat**은 전통적인 **서블릿 컨테이너**로, **블로킹 I/O** 방식으로 요청을 처리한다. Tomcat은 **요청당 하나의 스레드**를 할당하여 요청이 완료될 때까지 스레드가 블로킹된다. 이 방식은 적은 요청을 처리하는 웹 애플리케이션에는 적합하지만, 대규모 트래픽을 처리할 때는 비효율적이다.

- **블로킹 I/O**: Tomcat은 블로킹 방식으로 요청을 처리하므로, 하나의 요청이 완료될 때까지 스레드가 블로킹된다. 이는 다수의 요청을 처리할 때 **스레드 수의 한계**로 인해 성능 저하가 발생할 수 있다.
- **확장성 제한**: 스레드 기반의 요청 처리는 다수의 동시 요청을 처리하기에는 적합하지 않으며, 트래픽이 증가할수록 성능이 크게 저하될 수 있다. 그러나 Tomcat 8.5 이상에서는 **논블로킹 I/O**를 지원하며, WebFlux와 함께 사용할 수 있다.

### 📌 Netty vs Tomcat 비교

|  **특징**  | **Netty**  | **Tomcat**  |
|:----:|:------------:|:--------------------:|
| **아키텍처** | 비동기 이벤트 기반 | 요청당 하나의 스레드 할당 |
| **I/O 처리** | 논블로킹 I/O | 블로킹 I/O |
| **성능** | 높은 성능과 확장성 제공 | 동기 처리로 인한 성능 저하 |
| **확장성** | 다수의 요청 처리에 최적화 | 스레드 수에 따라 확장성 제한 |
| **사용 용이성** | 학습 곡선이 있음 | 전통적인 서블릿 아키텍처로 사용 용이 |

Netty는 특히 **비동기 처리**와 **고성능 시스템**에 최적화되어 있으며, Tomcat은 전통적인 서블릿 기반 애플리케이션에 더 적합하다. WebFlux는 Netty와의 조합에서 성능을 극대화할 수 있지만, Tomcat에서도 실행이 가능하다.

<br><br>

## ✅ 이벤트 루프(Event Loop)와 비동기 처리

WebFlux의 중요한 개념 중 하나는 이벤트 루프(Event Loop)다. 이벤트 루프는 **비동기 작업**을 처리하는 데 핵심적인 역할을 한다. Netty와 같은 비동기 서버는 이벤트 루프를 통해 작업을 관리하며, 요청이 들어오면 이를 **이벤트 큐**에 저장한 후, 이벤트 루프가 하나씩 처리하는 방식으로 동작한다.

### 📌 이벤트 루프 동작 원리

1. **이벤트 감지**: 클라이언트 요청, 파일 I/O, 네트워크 이벤트 등의 이벤트가 발생하면 이를 이벤트 큐에 등록한다.
2. **이벤트 큐 처리**: 이벤트 루프는 이벤트 큐에 저장된 이벤트를 하나씩 꺼내 처리한다. 이때 논블로킹 방식으로 동작하여 다른 이벤트가 대기하지 않도록 한다.
3. **콜백 실행**: 각 이벤트가 처리되면 등록된 콜백 함수가 실행되며, 결과를 반환하거나 후속 작업을 처리한다.

이벤트 루프는 다수의 요청을 **비동기**로 처리할 수 있기 때문에, **CPU 자원**을 효율적으로 사용할 수 있고, 서버가 더 많은 동시 요청을 처리할 수 있다. 특히, **I/O 작업**이 많은 시스템에서 이벤트 루프는 성능을 극대화하는 데 중요한 역할을 한다.

<br><br>

## ✅ WebFlux와 Spring MVC의 통합 가능성

Spring WebFlux와 Spring MVC는 서로 다른 아키텍처를 기반으로 하지만, 동일한 애플리케이션에서 함께 사용할 수 있다. **Spring Boot 2.0 이상**에서는 WebFlux와 Spring MVC를 혼합하여 사용할 수 있으며, 필요에 따라 각각의 모델을 선택적으로 활용할 수 있다.

### 📌 WebFlux와 MVC의 공존

- **서블릿 기반 WebFlux**: WebFlux는 **서블릿 3.1 이상**을 지원하는 컨테이너에서 **논블로킹 I/O**를 사용하여 동작한다. 따라서 Tomcat, Jetty와 같은 전통적인 서블릿 컨테이너에서도 WebFlux를 사용할 수 있다.
- **혼합 사용**: WebFlux는 비동기 처리에, Spring MVC는 동기 처리에 적합하다. 따라서 **REST API**와 같은 고성능이 필요한 부분에서는 WebFlux를, 전통적인 HTML 렌더링이나 동기식 처리에는 Spring MVC를 혼합해 사용할 수 있다.
- **WebClient 사용**: Spring MVC에서는 **RestTemplate** 대신 **WebClient**를 사용하여 비동기 HTTP 요청을 처리할 수 있다. WebClient는 WebFlux의 HTTP 클라이언트로 설계되었으며, 동기와 비동기 요청 모두를 지원한다.

### 📌 Spring MVC와 WebFlux의 선택 기준

- **동기적 처리**가 필요하거나 **전통적인 서블릿 기반 아키텍처**를 사용하는 경우에는 **Spring MVC**가 더 적합하다.
- 반면, **비동기 I/O**가 필요한 대규모 트래픽 환경이나 **API 서비스**에서는 **Spring WebFlux**가 훨씬 더 효율적이다.

<br><br>

## ✅ Non-Blocking I/O와 성능 최적화

WebFlux의 핵심 장점은 **Non-Blocking I/O**를 통한 성능 최적화에 있다. Non-Blocking I/O는 요청을 처리할 때 스레드가 **블로킹**되지 않으므로, 동일한 리소스로 더 많은 요청을 처리할 수 있게 한다.

### 📌 WebFlux 성능 최적화 기법

1. **이벤트 루프 최적화**: 이벤트 루프는 WebFlux의 중요한 부분으로, 이를 적절히 관리하면 대규모 트래픽을 처리할 때 성능을 극대화할 수 있다.
2. **스레드 풀 관리**: WebFlux는 기본적으로 **이벤트 루프 기반**으로 동작하므로, 스레드 풀의 크기를 적절하게 설정하여 불필요한 스레드 증가를 방지하고 성능을 유지할 수 있다.
3. **백프레셔(Backpressure)**: 데이터 소비자가 처리할 수 있는 양에 맞춰 데이터를 제공하는 **백프레셔**는 메모리 오버헤드를 줄이고 효율적인 데이터 처리를 돕는다.
4. **캐싱 활용**: 자주 호출되는 데이터를 캐싱하여, DB나 외부 API로의 불필요한 호출을 줄여 성능을 최적화할 수 있다.
5. **웹소켓 연계**: 실시간 데이터 처리가 필요한 시스템에서는 **WebFlux**와 **WebSocket**을 결합하여 양방향 통신을 구현할 수 있다.

<br><br>

## ✅ 결론

Spring WebFlux는 **논블로킹 I/O**와 **비동기 프로그래밍**을 통해 성능과 확장성을 극대화할 수 있는 강력한 도구다. 특히 **I/O 바운드 작업**이 많은 환경에서 뛰어난 성능을 발휘하며, **Netty**를 기반으로 한 서버 아키텍처는 비동기 처리에서 매우 우수한 성능을 보인다.

Spring MVC와 WebFlux는 동일한 프로젝트 내에서 공존할 수 있으며, 각각의 특성에 맞게 혼합하여 사용하는 것이 가능하다. 대규모 트래픽을 처리하는 시스템 구축이나 **마이크로서비스 아키텍처**를 도입할 때, WebFlux는 성능 최적화를 위한 좋은 선택이 될 수 있다.

<br><br>

---

**참고 자료**
- Spring 공식 문서: https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html
- Reactor 프로젝트: https://projectreactor.io/
