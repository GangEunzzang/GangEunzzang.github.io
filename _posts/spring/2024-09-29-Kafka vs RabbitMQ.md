---
title: Kafka vs RabbitMQ 
date: 2024-09-10 12:00:00 +09:00
categories: [architecture, message-queue]
tags:
  [
    kafka,
    rabbitmq,
    비동기 프로그래밍,
    이벤트 기반 아키텍처,
    시스템 설계,
    메시징 시스템
  ]
---

---

현대의 웹 애플리케이션은 성능과 확장성에 대한 요구가 높아지고 있다. **비동기 처리**와 **이벤트 기반 아키텍처**는 이러한 요구를 충족하기 위한 중요한 설계 방식이다. 동기적 처리 방식은 간단하지만, 대규모 트래픽이나 복잡한 비즈니스 로직을 처리할 때 비동기 처리로 전환해야 효율을 극대화할 수 있다.

이번 글에서는 비동기 처리의 필요성과 **RabbitMQ**, **Apache Kafka**와 같은 메시징 시스템을 사용하여 어떻게 시스템의 성능과 확장성을 개선할 수 있는지 설명한다.

<br>

## ✅ 비동기 처리란?

**비동기 처리**는 요청을 보낸 후 응답을 기다리지 않고 다른 작업을 계속 진행하는 방식이다. 이는 **동기 처리**와는 달리 I/O 작업이 완료될 때까지 스레드를 차단하지 않아 효율적인 자원 관리가 가능하다. 비동기 처리의 주요 이점은 다음과 같다:

- **높은 동시성**: 더 많은 요청을 동시에 처리할 수 있다.
- **확장성**: 시스템 리소스를 효율적으로 사용하여 대규모 트래픽을 처리할 수 있다.
- **장애 격리**: 각 작업이 독립적으로 처리되기 때문에 장애가 발생해도 다른 작업에 영향을 주지 않는다.

이러한 비동기 처리는 주로 마이크로서비스 아키텍처나 대규모 트래픽이 발생하는 시스템에서 유용하다.

<br>

## ✅ 이벤트 기반 아키텍처

**이벤트 기반 아키텍처**는 시스템 내에서 발생하는 **이벤트**(데이터 변경, 사용자 동작 등)를 기반으로 비즈니스 로직을 처리하는 방식이다. 이벤트 기반 시스템은 **프로듀서(Producer)**와 **컨슈머(Consumer)**로 나뉘어 동작하며, **메시지 브로커(Message Broker)**가 이벤트를 중계한다.

### 📌 주요 개념

- **이벤트**: 시스템에서 발생하는 상태 변화, 예를 들어 주문 생성, 결제 완료 등이 해당된다.
- **프로듀서**: 이벤트를 발생시키는 주체. 예를 들어, 사용자가 결제 버튼을 누르면 결제 시스템이 이벤트를 발생시킨다.
- **컨슈머**: 이벤트를 처리하는 주체. 결제 시스템의 결제 완료 이벤트를 받아 배송 시스템이 처리한다.
- **메시지 브로커**: 프로듀서가 발생시킨 이벤트를 컨슈머에게 전달하는 역할을 한다.

이벤트 기반 아키텍처는 특히 마이크로서비스 환경에서 확장성과 독립성을 유지하는 데 유리하다.

### 📌 장점

1. **비동기성**: 이벤트를 비동기로 처리할 수 있어 시스템의 응답성이 높아진다.
2. **확장성**: 새로운 기능을 추가할 때 기존 시스템에 영향을 주지 않고 새로운 이벤트 컨슈머만 추가하면 된다.
3. **내결함성**: 장애가 발생해도 메시지 브로커가 메시지를 보존하기 때문에 데이터 손실이 적다.

### 📌 단점

1. **복잡성 증가**: 메시지 큐를 도입하고 이벤트 흐름을 관리하는 데 추가적인 설계가 필요하다.
2. **트랜잭션 관리 어려움**: 분산 트랜잭션을 관리하는 것이 어렵고, 데이터 일관성을 유지하기 위한 추가적인 고려가 필요하다.

<br>

## ✅ RabbitMQ와 Kafka를 통한 비동기 처리

**RabbitMQ**와 **Kafka**는 대표적인 메시지 브로커로, 시스템 간 통신을 비동기적으로 처리하는 데 자주 사용된다. 두 시스템은 목적과 사용 방식이 다르기 때문에 적절한 선택이 중요하다.

### 📌 RabbitMQ

**RabbitMQ**는 신뢰성과 메시지 전송 보장을 중시하는 메시지 브로커다. **AMQP(Advanced Message Queuing Protocol)** 기반으로, **트랜잭션 처리**나 **상태 변경 이벤트**와 같은 중요한 메시지 전송에 자주 사용된다.

#### 주요 특징

- **메시지 내구성**: 메시지를 디스크에 저장해 브로커가 재시작되더라도 메시지가 손실되지 않는다.
- **다양한 라우팅 패턴**: 다이렉트, 팬아웃, 토픽 등의 다양한 메시지 라우팅 방식을 지원한다.
- **확장성**: 여러 노드로 확장 가능하며, 클러스터링을 통해 메시지를 분산 처리할 수 있다.

**RabbitMQ**는 **상태 기반 처리**가 중요한 트랜잭션 환경이나 안정적 메시지 전달이 필요한 시스템에 적합하다. 결제 시스템과 같은 중요한 서비스에서 자주 사용된다.

<br>

### 📌 Kafka

**Apache Kafka**는 **대규모 데이터 스트림**을 처리하는 데 특화된 분산 메시징 시스템이다. Kafka는 실시간 데이터 처리, 로그 수집, 이벤트 스트리밍 등에서 성능과 확장성을 극대화할 수 있다.

#### 주요 특징

- **높은 처리량**: Kafka는 초당 수백만 건의 메시지를 처리할 수 있다.
- **분산성**: 분산형 아키텍처로 브로커 간 메시지를 분산 저장하여 확장성과 가용성을 높인다.
- **메시지 복제**: 메시지를 여러 파티션에 복제해 데이터 손실을 방지하며, 메시지 스트리밍을 안정적으로 처리한다.

**Kafka**는 실시간 로그 분석이나 대규모 이벤트 기반 시스템에서 주로 사용되며, 특히 **대용량 데이터 처리**에 최적화되어 있다.

<br>

### 📌 RabbitMQ vs Kafka 비교

| **특징**               | **RabbitMQ**                        | **Kafka**                             |
|------------------------|-------------------------------------|---------------------------------------|
| **주요 용도**           | 트랜잭션 처리, 상태 변경 이벤트    | 실시간 데이터 스트림 처리, 로그 수집 |
| **메시지 전송 보장**    | 1회 전송, 메시지 내구성 보장        | 최소 1회 전송, 메시지 복제 지원       |
| **확장성**             | 클러스터링 지원, 중간 수준 확장성   | 매우 높은 확장성, 분산 아키텍처      |
| **처리량**             | 중간 수준                           | 매우 높은 처리량                     |
| **메시지 순서 보장**    | 보장되지 않음                      | 파티션 내에서 메시지 순서 보장        |
| **사용 패턴**           | 큐 기반 메시징, 다양한 라우팅 패턴  | 로그 기반 메시징, 스트림 처리        |

**RabbitMQ**는 **트랜잭션 중심**의 상태 변경 처리가 필요한 환경에, **Kafka**는 **대용량 로그 처리**나 **실시간 스트리밍**이 필요한 시스템에 더 적합하다.

<br>

## ✅ 적용 사례

### 📌 전자상거래 시스템

전자상거래 시스템에서는 결제, 재고 관리, 배송 등을 비동기로 처리해야 할 경우가 많다. RabbitMQ를 사용해 주문 생성 시 결제 처리를 비동기로 처리하고, Kafka를 통해 실시간으로 로그를 수집하고 분석할 수 있다.

### 📌 실시간 데이터 처리

실시간 데이터 분석 시스템에서는 Kafka가 유리하다. 사용자의 행동 데이터를 실시간으로 수집하고, 이를 기반으로 마케팅 또는 상품 추천에 활용할 수 있다. Kafka의 고성능 스트리밍 처리 기능이 대규모 트래픽을 처리하는 데 최적화되어 있다.

### 📌 마이크로서비스 아키텍처

마이크로서비스 간의 통신은 독립적이어야 하므로 비동기 처리가 필수적이다. RabbitMQ나 Kafka를 통해 서비스 간 통신을 비동기로 처리하면 시스템 전체의 응답성을 높일 수 있다. 특히 Kafka는 로그 스트리밍을 통해 장애를 분석하고 예측하는 데 도움이 된다.

<br>

## ✅ 결론

**비동기 처리**와 **이벤트 기반 아키텍처**는 현대 애플리케이션에서 확장성과 성능을 극대화하는 데 중요한 역할을 한다. **RabbitMQ**는 신뢰성 있는 메시지 전달이 중요한 트랜잭션 처리에 적합하며, **Kafka**는 대규모 실시간 데이터 처리에 최적화된 시스템이다.

이 두 메시징 시스템은 각자의 장점이 있기 때문에, 사용 목적에 따라 선택하거나 함께 사용해 성능을 극대화할 수 있다. 이 글에서 설명한 아키텍처와 메시징 시스템을 적절히 활용해 대규모 트래픽을 효율적으로 처리하는 시스템을 설계할 수 있을 것이다.

---

**참고 자료**
- [RabbitMQ 공식 문서](https://www.rabbitmq.com/)
- [Apache Kafka 공식 문서](https://kafka.apache.org/)
