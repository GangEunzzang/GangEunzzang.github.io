---
title: Kafka vs RabbitMQ  
date: 2024-09-10 12:00:00 +09:00  
categories: [architecture, message-queue]  
tags:  
  [kafka, rabbitmq, 비동기 프로그래밍, 이벤트 기반 아키텍처, 시스템 설계, 메시징 시스템]  
---

---

현대 웹 애플리케이션은 성능과 확장성 요구가 커지고 있습니다. **비동기 처리**와 **이벤트 기반 아키텍처**는 이를 해결하는 중요한 방식입니다. 동기 처리보다 비동기 처리는 대규모 트래픽과 복잡한 로직 처리에 더 적합합니다.

이 글에서는 비동기 처리의 필요성과 **RabbitMQ**, **Apache Kafka**를 사용해 성능과 확장성을 개선하는 방법을 설명합니다.

<br>

## ✅ 비동기 처리란?

**비동기 처리**는 요청 후 응답을 기다리지 않고 다른 작업을 계속할 수 있는 방식이다.  
**동기 처리**와 달리 I/O 작업을 기다리느라 자원을 낭비하지 않는다.

- **높은 동시성**: 많은 요청을 동시에 처리
- **확장성**: 자원을 효율적으로 사용해 대규모 트래픽 처리
- **장애 격리**: 작업 간 독립적 처리로 장애 발생 시 영향 최소화

<br>

## ✅ 이벤트 기반 아키텍처

**이벤트 기반 아키텍처**는 시스템에서 발생하는 **이벤트**를 중심으로 비즈니스 로직을 처리하는 방식이다.  
**프로듀서**는 이벤트를 발생시키고, **컨슈머**는 이를 처리한다. **메시지 브로커**가 이 둘을 연결해 준다.

### 📌 주요 개념

- **이벤트**: 시스템 상태 변화 (예: 주문 생성, 결제 완료)
- **프로듀서**: 이벤트를 발생시키는 주체
- **컨슈머**: 이벤트를 받아 처리하는 주체
- **메시지 브로커**: 이벤트를 전달하는 중간 역할

### 📌 장점

1. **비동기성**: 이벤트를 비동기로 처리해 응답성 향상
2. **확장성**: 시스템에 영향을 주지 않고 새로운 기능 추가
3. **내결함성**: 장애 발생 시 메시지 보존으로 데이터 손실 최소화

### 📌 단점

1. **복잡성 증가**: 추가 설계 필요
2. **트랜잭션 관리 어려움**: 분산 환경에서 데이터 일관성 유지 어려움

<br>

## ✅ RabbitMQ와 Kafka를 통한 비동기 처리

**RabbitMQ**와 **Kafka**는 대표적인 메시지 브로커이다. 하지만 이 둘은 사용 목적과 방식이 다르다.

### 📌 RabbitMQ

**RabbitMQ**는 신뢰성 있는 메시지 전송이 필요한 시스템에 적합하다.   
**AMQP** 기반으로 **트랜잭션 처리**와 **상태 변경 이벤트**를 다룰 때 많이 사용된다.

#### 주요 특징

- **메시지 내구성**: 메시지를 디스크에 저장해 재시작 시에도 메시지 유지
- **다양한 라우팅 패턴**: 다이렉트, 팬아웃, 토픽 라우팅 지원
- **확장성**: 클러스터링으로 확장 가능

### 📌 Kafka

**Apache Kafka**는 **대규모 데이터 스트림** 처리에 특화된 분산 메시징 시스템이다.  
**실시간 로그 처리**, **이벤트 스트리밍**에 적합하다.

#### 주요 특징

- **높은 처리량**: 초당 수백만 건의 메시지 처리
- **분산성**: 메시지를 여러 브로커에 분산 저장해 확장성 극대화
- **메시지 복제**: 복제를 통해 데이터 손실 방지

<br>

### 📌 RabbitMQ vs Kafka 비교

| **특징**               | **RabbitMQ**                        | **Kafka**                             |
|------------------------|-------------------------------------|---------------------------------------|
| **주요 용도**           | 트랜잭션 처리, 상태 변경 이벤트    | 실시간 데이터 스트림 처리, 로그 수집 |
| **메시지 전송 보장**    | 1회 전송, 메시지 내구성 보장        | 최소 1회 전송, 메시지 복제 지원       |
| **확장성**             | 클러스터링 지원, 중간 수준 확장성   | 매우 높은 확장성, 분산 아키텍처      |
| **처리량**             | 중간 수준                           | 매우 높은 처리량                     |
| **메시지 순서 보장**    | 보장되지 않음                      | 파티션 내에서 메시지 순서 보장        |
| **사용 패턴**           | 큐 기반 메시징, 다양한 라우팅 패턴  | 로그 기반 메시징, 스트림 처리        |

**RabbitMQ**는 **트랜잭션 중심**의 처리에,  
**Kafka**는 **대용량 로그 처리**나 **실시간 스트리밍**에 적합

<br>

## ✅ 적용 사례

### 📌 전자상거래 시스템

전자상거래 시스템에서 RabbitMQ는 주문 생성 후 결제 처리를 비동기로 처리하는 데 유용하며, Kafka는 실시간 로그 수집 및 분석에 적합

### 📌 실시간 데이터 처리

Kafka는 실시간 행동 데이터를 수집해 마케팅이나 상품 추천에 활용하는 데 유리하다.

### 📌 마이크로서비스 아키텍처

RabbitMQ나 Kafka를 통해 서비스 간 통신을 비동기로 처리해 시스템 응답성을 높일 수 있다.

<br>

## ✅ 결론

**비동기 처리**와 **이벤트 기반 아키텍처**는 성능과 확장성을 극대화하는 데 필수적입니다.   
**RabbitMQ**는 신뢰성 있는 트랜잭션 처리에, **Kafka**는 대규모 실시간 데이터 처리에 적합합니다. 필요에 따라 두 시스템을 적절히 활용해 효율적인 시스템을 설계할 수 있습니다.

---

**참고 자료**
- [RabbitMQ 공식 문서](https://www.rabbitmq.com/)
- [Apache Kafka 공식 문서](https://kafka.apache.org/)  
