---
title: FastAPI í†ºì•„ë³´ê¸°
date: 2025-11-16 13:00:00 +09:00
categories: [python, fastapi]
tags:
  [
    python,
    fastapi,
  ]
---

FastAPI ê³µì‹ ë¬¸ì—ì„œëŠ” FastAPIë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•˜ê³  ìˆìŠµë‹ˆë‹¤.

> FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.

ì¦‰, FastAPIëŠ” í‘œì¤€ Python íƒ€ì… íŒíŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ APIë¥¼ êµ¬ì¶•í•˜ê¸° ìœ„í•œ í˜„ëŒ€ì ì´ê³  ë¹ ë¥¸ ê³ ì„±ëŠ¥ ì›¹ í”„ë ˆì„ì›Œí¬ì…ë‹ˆë‹¤.

FastAPIê°€ ì–´ë–»ê²Œ êµ¬ì„±ë˜ì–´ ìˆê³  ì–´ë–¤ ì¥ì ì´ ìˆëŠ”ì§€ í•˜ë‚˜ì”© ê³µì‹ ë¬¸ì„œë¥¼ ì°¸ê³ í•˜ì—¬ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

ë¶„ì„ ì¤‘ ë‚˜ì˜¤ëŠ” ëª¨ë“  ì½”ë“œëŠ” ì•„ë˜ í™˜ê²½ì„ê¸°ì¤€ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

##  ğŸ³ ë¶„ì„ í™˜ê²½
- fastAPI: 0.121.1
- python: 3.13
- pydantic: 2.12.4

---

## âœ… FastAPIì˜ êµ¬ì„±
FastAPIëŠ” í¬ê²Œ ë‘ ê°€ì§€ í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ ìœ„ì—ì„œ ë™ì‘í•©ë‹ˆë‹¤.

1. **Starlette**: ASGI ê¸°ë°˜ì˜ ë¹„ë™ê¸° ì›¹ í”„ë ˆì„ì›Œí¬ë¡œ, FastAPIì˜ ì›¹ ì„œë²„ ê¸°ëŠ¥ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤. ë¼ìš°íŒ…, ë¯¸ë“¤ì›¨ì–´, Request/Response ì²˜ë¦¬ ë“± ì›¹ í”„ë ˆì„ì›Œí¬ì˜ ê¸°ë³¸ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
2. **Pydantic**: íƒ€ì… íŒíŠ¸ ê¸°ë°˜ì˜ ë°ì´í„° ê²€ì¦ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ, ìš”ì²­ ë° ì‘ë‹µ ë°ì´í„°ì˜ ìë™ ê²€ì¦ê³¼ ì§ë ¬í™”ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤.

FastAPIëŠ” ì´ ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê°œë°œì í¸ì˜ì„±ì„ ëŒ€í­ ê°•í™”í•œ í”„ë ˆì„ì›Œí¬ë¼ê³  ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € Starletteì˜ ì—­í• ë¶€í„° ìì„¸íˆ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

### ğŸ“Œ Starlette
StarletteëŠ” FastAPIì˜ ê¸°ë°˜ì´ ë˜ëŠ” ASGI ì›¹ í”„ë ˆì„ì›Œí¬ì…ë‹ˆë‹¤. FastAPIëŠ” ì‹¤ì œë¡œ Starletteë¥¼ ìƒì†ë°›ì•„ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ì½”ë“œë¥¼ í†µí•´ ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

```python
from fastapi import FastAPI

app.get("/root")
async def root():
    return {"message": "Hello World"}

```

ìœ„ ì½”ë“œì—ì„œëŠ” `FastAPI` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³  `@app.get("/root")` ë°ì½”ë ˆì´í„°ë¡œ `/root` ê²½ë¡œì— ëŒ€í•œ GET ìš”ì²­ í•¸ë“¤ëŸ¬ë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.

FastAPI í´ë˜ìŠ¤ì˜ ë‚´ë¶€ êµ¬í˜„ì„ ë“¤ì—¬ë‹¤ë³´ë©´ (`fastapi/applications.py`), Starletteë¥¼ importí•˜ê³  ìƒì†ë°›ê³  ìˆëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

FastAPI Class ë“¤ì–´ê°€ë©´ `application.py` íŒŒì¼ì´ ë‚˜ì˜¤ëŠ”ë° ê±°ê¸°ì„œ `Starletteë¥¼ import` í•˜ê³  ìˆìŠµë‹ˆë‹¤.

```python
from starlette.applications import Starlette

class FastAPI(Starlette):
    def __init__(self, ...):
```

ì´ì²˜ëŸ¼ FastAPIëŠ” Starletteì˜ í•µì‹¬ ê¸°ëŠ¥ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë©´ì„œ, ê·¸ ìœ„ì— ì¶”ê°€ì ì¸ í¸ì˜ ê¸°ëŠ¥ë“¤ì„ ì˜¬ë¦° êµ¬ì¡°ì…ë‹ˆë‹¤.

<br>

#### 1ï¸âƒ£ ë¼ìš°íŒ… (Routing)

Starletteì˜ ê°€ì¥ í•µì‹¬ì ì¸ ê¸°ëŠ¥ì€ ë¼ìš°íŒ…ì…ë‹ˆë‹¤. ë¼ìš°íŒ…ì´ë€ í´ë¼ì´ì–¸íŠ¸ì˜ HTTP ìš”ì²­ì„ ì ì ˆí•œ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ë¡œ ì—°ê²°í•´ì£¼ëŠ” ì‘ì—…ì„ ë§í•©ë‹ˆë‹¤.
`ex) Springì˜ Dispatcher Servlet ì—­í• `

`/starlette/routing.py` íŒŒì¼ì„ ì‚´í´ë³´ë©´ ë¼ìš°íŒ…ì˜ í•µì‹¬ í´ë˜ìŠ¤ë“¤ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**Router í´ë˜ìŠ¤**
```python
class Router:
    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        redirect_slashes: bool = True,
        default: ASGIApp | None = None,
        on_startup: Sequence[Callable[[], Any]] | None = None,
        on_shutdown: Sequence[Callable[[], Any]] | None = None,
        lifespan: Lifespan[Any] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.redirect_slashes = redirect_slashes
        self.default = self.not_found if default is None else default
        # ...
```

`Router` í´ë˜ìŠ¤ëŠ” ì—¬ëŸ¬ ê°œì˜ `Route`ë¥¼ ê´€ë¦¬í•˜ëŠ” í•µì‹¬ í´ë˜ìŠ¤ì…ë‹ˆë‹¤. ì£¼ìš” íŒŒë¼ë¯¸í„°ë¥¼ ì‚´í´ë³´ë©´:

- `routes`: Route ê°ì²´ë“¤ì˜ ë¦¬ìŠ¤íŠ¸
- `redirect_slashes`: ìŠ¬ë˜ì‹œ(`/`) ë¦¬ë‹¤ì´ë ‰ì…˜ ì—¬ë¶€ (ì˜ˆ: `/users/` â†’ `/users`)
- `default`: ë§¤ì¹­ë˜ëŠ” ë¼ìš°íŠ¸ê°€ ì—†ì„ ë•Œ ì‹¤í–‰ë  ê¸°ë³¸ í•¸ë“¤ëŸ¬
- `on_startup`, `on_shutdown`: ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘/ì¢…ë£Œ ì‹œ ì‹¤í–‰ë  í•¨ìˆ˜ë“¤ (deprecated)
- `lifespan`: ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒëª…ì£¼ê¸° ê´€ë¦¬ë¥¼ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € (ìµœì‹  ë°©ì‹)
- `middleware`: ìš”ì²­/ì‘ë‹µ ì²˜ë¦¬ì— ì ìš©ë  ë¯¸ë“¤ì›¨ì–´ ë¦¬ìŠ¤íŠ¸

RouterëŠ” ë“±ë¡ëœ ëª¨ë“  ë¼ìš°íŠ¸ë¥¼ ìˆœíšŒí•˜ë©° ìš”ì²­ê³¼ ë§¤ì¹­ë˜ëŠ” ë¼ìš°íŠ¸ë¥¼ ì°¾ì•„ í•´ë‹¹ í•¸ë“¤ëŸ¬ë¥¼ ì‹¤í–‰ì‹œí‚µë‹ˆë‹¤.

FastAPIì—ì„œ `@app.get()`, `@app.post()` ê°™ì€ ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ë©´, ë‚´ë¶€ì ìœ¼ë¡œëŠ” ì´ `Route` ê°ì²´ê°€ ìƒì„±ë˜ì–´ `Router`ì— ë“±ë¡ë˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´:
```python
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}
```

ì´ ì½”ë“œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ì´ ë™ì‘í•©ë‹ˆë‹¤:
```python
# ë‚´ë¶€ ë™ì‘ (simplified)
route = Route(
    path="/users/{user_id}",
    endpoint=get_user,
    methods=["GET"]
)
app.router.routes.append(route)
```

ìš”ì²­ì´ ë“¤ì–´ì˜¤ë©´:
1. Routerê°€ ë“±ë¡ëœ ëª¨ë“  Routeë¥¼ ìˆœíšŒ
2. ê° Routeì˜ `matches()` ë©”ì„œë“œë¡œ ê²½ë¡œ ë§¤ì¹­ í™•ì¸
3. ë§¤ì¹­ë˜ëŠ” Routeë¥¼ ì°¾ìœ¼ë©´ í•´ë‹¹ endpoint í•¨ìˆ˜ ì‹¤í–‰
4. path parameterëŠ” ìë™ìœ¼ë¡œ ì¶”ì¶œë˜ì–´ í•¨ìˆ˜ ì¸ìë¡œ ì „ë‹¬
5. ë§¤ì¹­ë˜ëŠ” Routeê°€ ì—†ìœ¼ë©´ `default` í•¸ë“¤ëŸ¬ ì‹¤í–‰ (ë³´í†µ 404 ì—ëŸ¬)

<br>

#### 2ï¸âƒ£ ë¯¸ë“¤ì›¨ì–´ (Middleware)

ë¯¸ë“¤ì›¨ì–´ëŠ” ìš”ì²­ì´ ë¼ìš°íŠ¸ í•¸ë“¤ëŸ¬ì— ë„ë‹¬í•˜ê¸° ì „ê³¼ ì‘ë‹µì´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ë‹¬ë˜ê¸° ì „ì— ì‹¤í–‰ë˜ëŠ” ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤. ë¡œê¹…, ì¸ì¦, CORS ì²˜ë¦¬, ì••ì¶• ë“± ê³µí†µì ì¸ ì²˜ë¦¬ ë¡œì§ì„ ë¯¸ë“¤ì›¨ì–´ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`ex) Springì˜ Filter ë˜ëŠ” interceptor ì—­í• ` 


StarletteëŠ” `starlette/middleware` íŒ¨í‚¤ì§€ì—ì„œ ë‹¤ì–‘í•œ ë¯¸ë“¤ì›¨ì–´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

**ë¯¸ë“¤ì›¨ì–´ì˜ ë™ì‘ ë°©ì‹**
```python
from starlette.middleware.base import BaseHTTPMiddleware

class CustomMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        # ìš”ì²­ ì²˜ë¦¬ ì „ ë¡œì§
        print(f"Request: {request.url}")
        
        # ë‹¤ìŒ ë¯¸ë“¤ì›¨ì–´ ë˜ëŠ” ë¼ìš°íŠ¸ í•¸ë“¤ëŸ¬ í˜¸ì¶œ
        response = await call_next(request)
        
        # ì‘ë‹µ ì²˜ë¦¬ í›„ ë¡œì§
        print(f"Response status: {response.status_code}")
        
        return response
```

ë¯¸ë“¤ì›¨ì–´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìˆœì„œë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤:
```
Client Request
    â†“
Middleware 1 (before)
    â†“
Middleware 2 (before)
    â†“
Route Handler
    â†“
Middleware 2 (after)
    â†“
Middleware 1 (after)
    â†“
Client Response
```

**Middleware í´ë˜ìŠ¤**
```python
# starlette/middleware/__init__.py
@dataclass
class Middleware:
  def __init__(self, cls: _MiddlewareFactory[P], *args: P.args, **kwargs: P.kwargs) -> None:
    self.cls = cls
    self.args = args
    self.kwargs = kwargs
```

`Middleware` í´ë˜ìŠ¤ëŠ” ë¯¸ë“¤ì›¨ì–´ì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ë‹´ëŠ” ë°ì´í„° í´ë˜ìŠ¤ì…ë‹ˆë‹¤:

- `cls`: ì‹¤ì œ ë¯¸ë“¤ì›¨ì–´ í´ë˜ìŠ¤
- `args`: ë¯¸ë“¤ì›¨ì–´ ìƒì„±ìì— ì „ë‹¬í•  ìœ„ì¹˜ ì¸ì
- `kwargs`: ë¯¸ë“¤ì›¨ì–´ ìƒì„±ìì— ì „ë‹¬í•  í‚¤ì›Œë“œ ì¸ì

FastAPIì—ì„œ ë¯¸ë“¤ì›¨ì–´ë¥¼ ë“±ë¡í•˜ëŠ” ë°©ë²•ì€ í¬ê²Œ ë‘ ê°€ì§€ì…ë‹ˆë‹¤:

**ë°©ë²• 1: ë°ì½”ë ˆì´í„° ì‚¬ìš©**
```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    import time
    start_time = time.time()
    
    response = await call_next(request)
    
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

**ë°©ë²• 2: add_middleware ë©”ì„œë“œ ì‚¬ìš©**
```python
from fastapi import FastAPI
from starlette.middleware.cors import CORSMiddleware
from starlette.middleware.gzip import GZipMiddleware

app = FastAPI()

# CORS ë¯¸ë“¤ì›¨ì–´
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# GZip ì••ì¶• ë¯¸ë“¤ì›¨ì–´
app.add_middleware(GZipMiddleware, minimum_size=1000)
```

**Starletteì˜ ì£¼ìš” ë‚´ì¥ ë¯¸ë“¤ì›¨ì–´**

1. **CORSMiddleware**: Cross-Origin Resource Sharing ì²˜ë¦¬
2. **GZipMiddleware**: ì‘ë‹µ ì••ì¶•
3. **TrustedHostMiddleware**: í—ˆìš©ëœ í˜¸ìŠ¤íŠ¸ë§Œ ì ‘ê·¼ ê°€ëŠ¥
4. **HTTPSRedirectMiddleware**: HTTPë¥¼ HTTPSë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
5. **SessionMiddleware**: ì„¸ì…˜ ê´€ë¦¬

**ë¯¸ë“¤ì›¨ì–´ ìŠ¤íƒ êµ¬ì„±**

Router í´ë˜ìŠ¤ì—ì„œ ë¯¸ë“¤ì›¨ì–´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±ë©ë‹ˆë‹¤:
```python
class Router:
    def __init__(
        self,
        routes: Sequence[BaseRoute] | None = None,
        *,
        middleware: Sequence[Middleware] | None = None,
    ) -> None:
        self.routes = [] if routes is None else list(routes)
        self.middleware = [] if middleware is None else list(middleware)
```

ë‚´ë¶€ì ìœ¼ë¡œ ë¯¸ë“¤ì›¨ì–´ë“¤ì€ ìŠ¤íƒ êµ¬ì¡°ë¡œ ìŒ“ì´ë©°, ìš”ì²­ì´ ë“¤ì–´ì˜¤ë©´ ì—­ìˆœìœ¼ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤:
```python
# ë¯¸ë“¤ì›¨ì–´ ë“±ë¡ ìˆœì„œ
app.add_middleware(Middleware1)  # ì²« ë²ˆì§¸
app.add_middleware(Middleware2)  # ë‘ ë²ˆì§¸
app.add_middleware(Middleware3)  # ì„¸ ë²ˆì§¸

# ì‹¤í–‰ ìˆœì„œ
# Request: Middleware3 â†’ Middleware2 â†’ Middleware1 â†’ Handler
# Response: Handler â†’ Middleware1 â†’ Middleware2 â†’ Middleware3
```

ì‹¤ì œ ì˜ˆì‹œë¡œ ë³´ë©´:
```python
from fastapi import FastAPI, Request
from starlette.middleware.cors import CORSMiddleware

app = FastAPI()

# 1. CORS ë¯¸ë“¤ì›¨ì–´ ë“±ë¡
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
)

# 2. ì»¤ìŠ¤í…€ ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
@app.middleware("http")
async def log_requests(request: Request, call_next):
    print(f"[Before] {request.method} {request.url}")
    response = await call_next(request)
    print(f"[After] Status: {response.status_code}")
    return response

@app.get("/test")
async def test():
    return {"message": "test"}
```

ìœ„ ì½”ë“œì—ì„œ `/test` ìš”ì²­ì´ ë“¤ì–´ì˜¤ë©´:

1. ë¡œê¹… ë¯¸ë“¤ì›¨ì–´ ì‹¤í–‰ (before) - `[Before] GET /test`
2. CORS ë¯¸ë“¤ì›¨ì–´ ì‹¤í–‰
3. ë¼ìš°íŠ¸ í•¸ë“¤ëŸ¬ ì‹¤í–‰ - `{"message": "test"}`
4. CORS ë¯¸ë“¤ì›¨ì–´ ì™„ë£Œ (CORS í—¤ë” ì¶”ê°€)
5. ë¡œê¹… ë¯¸ë“¤ì›¨ì–´ ì™„ë£Œ (after) - `[After] Status: 200`

ìœ„ì²˜ëŸ¼ ì²˜ë¦¬ë˜ì–´ ìˆœì„œë¥¼ ì—¼ë‘ì— ë‘ê³  ë¯¸ë“¤ì›¨ì–´ë¥¼ ì„¤ê³„í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

<br>

#### 3ï¸âƒ£ Request/Response ì²˜ë¦¬

StarletteëŠ” HTTP ìš”ì²­ê³¼ ì‘ë‹µì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ `Request`ì™€ ë‹¤ì–‘í•œ `Response` í´ë˜ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ í´ë¼ì´ì–¸íŠ¸ì™€ì˜ í†µì‹ ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
 `ex) Springì˜ HttpServletRequest, HttpServletResponse ì—­í• `
* Requestì™€ ResponseëŠ” ì œì™¸í• ê¹Œ í•˜ë‹¤ê°€ FastAPIì—ì„œ ì˜ì™¸ë¡œ ë‹¤ë£°ì¼ì´ ìˆì–´ì„œ í¬í•¨ì‹œì¼°ìŠµë‹ˆë‹¤.


**Request í´ë˜ìŠ¤**
```python
# starlette/requests.py
class Request(HTTPConnection):
  _form: FormData | None

  def __init__(self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send):
    super().__init__(scope)
    assert scope["type"] == "http"
    self._receive = receive
    self._send = send
    self._stream_consumed = False
    self._is_disconnected = False
    self._form = None
```

`Request` ê°ì²´ëŠ” í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ë°›ì€ HTTP ìš”ì²­ì˜ ëª¨ë“  ì •ë³´ë¥¼ ë‹´ê³  ìˆìŠµë‹ˆë‹¤. ì£¼ìš” ë©”ì„œë“œì™€ í”„ë¡œí¼í‹°ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

**ìš”ì²­ ë°ì´í„° íŒŒì‹±**
```python
# JSON ë°ì´í„° íŒŒì‹±
async def json(self) -> Any:
    if not hasattr(self, "_json"):
        body = await self.body()
        self._json = json_loads(body)
    return self._json

# Raw body ì½ê¸°
async def body(self) -> bytes:
    if not hasattr(self, "_body"):
        chunks: list[bytes] = []
        async for chunk in self.stream():
            chunks.append(chunk)
        self._body = b"".join(chunks)
    return self._body
```

**ìš”ì²­ ì •ë³´ ì ‘ê·¼**
```python
@property
def query_params(self) -> QueryParams:
    # URL ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° (ì˜ˆ: ?page=1&limit=10)
    if not hasattr(self, "_query_params"):
        self._query_params = QueryParams(self._scope["query_string"])
    return self._query_params

@property
def path_params(self) -> dict[str, Any]:
    # Path íŒŒë¼ë¯¸í„° (ì˜ˆ: /users/{user_id})
    return self._scope.get("path_params", {})

@property
def headers(self) -> Headers:
    # HTTP í—¤ë”
    if not hasattr(self, "_headers"):
        self._headers = Headers(scope=self._scope)
    return self._headers

@property
def cookies(self) -> dict[str, str]:
    if not hasattr(self, "_cookies"):
        cookies: dict[str, str] = {}
        cookie_header = self.headers.get("cookie")
        if cookie_header:
            cookies = parse_cookie(cookie_header)
        self._cookies = cookies
    return self._cookies
```

ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ:
```python
from starlette.requests import Request
from starlette.responses import JSONResponse

async def handle_request(request: Request):
    # ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
    page = request.query_params.get("page", "1")
    
    # Path íŒŒë¼ë¯¸í„°
    user_id = request.path_params.get("user_id")
    
    # í—¤ë”
    auth_token = request.headers.get("Authorization")
    
    # JSON body
    data = await request.json()
    
    # ì¿ í‚¤
    session_id = request.cookies.get("session_id")
    
    return JSONResponse({
        "page": page,
        "user_id": user_id,
        "has_auth": auth_token is not None
    })
```

**Response í´ë˜ìŠ¤**

StarletteëŠ” ë‹¤ì–‘í•œ ìƒí™©ì— ë§ëŠ” ì—¬ëŸ¬ Response í´ë˜ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
```python
# starlette/responses.py

# 1. ê¸°ë³¸ Response
class Response:
  media_type = None
  charset = "utf-8"

  def __init__(
    self,
    content: Any = None,
    status_code: int = 200,
    headers: Mapping[str, str] | None = None,
    media_type: str | None = None,
    background: BackgroundTask | None = None,
  ) -> None:
    self.status_code = status_code
    if media_type is not None:
      self.media_type = media_type
    self.background = background
    self.body = self.render(content)
    self.init_headers(headers)

# 2. JSON ì‘ë‹µ
class JSONResponse(Response):
    media_type = "application/json"

    def __init__(
      self,
      content: Any,
      status_code: int = 200,
      headers: Mapping[str, str] | None = None,
      media_type: str | None = None,
      background: BackgroundTask | None = None,
    ) -> None:
      super().__init__(content, status_code, headers, media_type, background)
      
    def render(self, content: Any) -> bytes:
        return json_dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        ).encode("utf-8")

# 3. HTML ì‘ë‹µ
class HTMLResponse(Response):
    media_type = "text/html"

# 4. íŒŒì¼ ì‘ë‹µ
class FileResponse(Response):
    chunk_size = 64 * 1024  # 64KB
    
    def __init__(
        self,
      path: str | os.PathLike[str],
      status_code: int = 200,
      headers: Mapping[str, str] | None = None,
      media_type: str | None = None,
      background: BackgroundTask | None = None,
      filename: str | None = None,
      stat_result: os.stat_result | None = None,
      method: str | None = None,
      content_disposition_type: str = "attachment",
    ) -> None:
        # ...

# 6. ë¦¬ë‹¤ì´ë ‰íŠ¸ ì‘ë‹µ
class RedirectResponse(Response):
    def __init__(
        self,
        url: str | URL,
        status_code: int = 307,
        headers: Mapping[str, str] | None = None,
      background: BackgroundTask | None = None,
    ) -> None:
        # ...
```

**Response ì‚¬ìš© ì˜ˆì‹œ**
```python
from starlette.responses import (
    JSONResponse, 
    HTMLResponse, 
    FileResponse,
    StreamingResponse,
    RedirectResponse
)

# JSON ì‘ë‹µ
@app.get("/api/users")
async def get_users():
    return JSONResponse({"users": [{"id": 1, "name": "John"}]})

# HTML ì‘ë‹µ
@app.get("/")
async def home():
    html_content = "<html><body><h1>Hello World</h1></body></html>"
    return HTMLResponse(content=html_content)

# íŒŒì¼ ë‹¤ìš´ë¡œë“œ
@app.get("/download")
async def download_file():
    return FileResponse(
        path="files/document.pdf",
        filename="download.pdf",
        media_type="application/pdf"
    )


# ë¦¬ë‹¤ì´ë ‰íŠ¸
@app.get("/old-url")
async def redirect():
    return RedirectResponse(url="/new-url")
```

**FastAPIì—ì„œì˜ í™œìš©**

FastAPIëŠ” Starletteì˜ Request/Responseë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë©´ì„œ, ì¶”ê°€ì ì¸ í¸ì˜ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤:
```python
from fastapi import FastAPI, Request
from starlette.responses import JSONResponse

app = FastAPI()

# Starlette Request ì§ì ‘ ì‚¬ìš© ê°€ëŠ¥
@app.get("/custom")
async def custom_handler(request: Request):
    # Starlette Request ê°ì²´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    user_agent = request.headers.get("user-agent")
    client_host = request.client.host
    
    return JSONResponse({
        "user_agent": user_agent,
        "client_ip": client_host
    })

# FastAPIëŠ” ìë™ìœ¼ë¡œ dictë¥¼ JSONResponseë¡œ ë³€í™˜
@app.get("/simple")
async def simple_handler():
    # ë‚´ë¶€ì ìœ¼ë¡œ JSONResponseë¡œ ë³€í™˜ë¨
    return {"message": "Hello"}
```

---
<br><br>

### ğŸ“Œ Pydantic

Pydanticì€ Python íƒ€ì… íŒíŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë°ì´í„° ê²€ì¦ê³¼ ì§ë ¬í™”ë¥¼ ìˆ˜í–‰í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤. FastAPIì—ì„œ ìš”ì²­/ì‘ë‹µ ë°ì´í„°ì˜ ìë™ ê²€ì¦, ë¬¸ì„œí™”, ì§ë ¬í™”ë¥¼ ë‹´ë‹¹í•˜ëŠ” í•µì‹¬ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.

`ex) Springì˜ @Valid, @RequestBody, DTO, Bean Validation ì—­í• `

<br>

#### 1ï¸âƒ£ BaseModel - ë°ì´í„° ê²€ì¦ì˜ í•µì‹¬

Pydanticì˜ ê°€ì¥ ê¸°ë³¸ì´ ë˜ëŠ” í´ë˜ìŠ¤ëŠ” `BaseModel`ì…ë‹ˆë‹¤. ëª¨ë“  ë°ì´í„° ëª¨ë¸ì€ ì´ í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ì•„ ì •ì˜í•©ë‹ˆë‹¤.

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str
    is_active: bool = True  # ê¸°ë³¸ê°’ ì„¤ì •
```

Springì—ì„œëŠ” DTOë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•©ë‹ˆë‹¤:
```java
public class UserDto {
    @NotNull
    private Long id;

    @NotBlank
    private String name;

    @Email
    private String email;

    private boolean isActive = true;
}
```

Pydanticì€ íƒ€ì… íŒíŠ¸ë§Œìœ¼ë¡œ ìë™ ê²€ì¦ì´ ì´ë£¨ì–´ì§€ë¯€ë¡œ, ë³„ë„ì˜ ì–´ë…¸í…Œì´ì…˜ ì—†ì´ë„ íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.

**BaseModel ë‚´ë¶€ êµ¬ì¡°**

`pydantic/main.py`ë¥¼ ì‚´í´ë³´ë©´:
```python
class BaseModel(metaclass=_model_construction.ModelMetaclass):
    """A base class for creating Pydantic models."""

    model_config: ClassVar[ConfigDict] = ConfigDict()
    """Configuration for the model, should be a dictionary conforming to ConfigDict."""

    __pydantic_complete__: ClassVar[bool] = False
    """Whether model building is completed, or if there are still undefined fields."""

    __pydantic_core_schema__: ClassVar[CoreSchema]
    """The core schema of the model."""

    __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]
    """The `pydantic-core` SchemaValidator used to validate instances of the model."""

    __pydantic_serializer__: ClassVar[SchemaSerializer]
    """The `pydantic-core` SchemaSerializer used to dump instances of the model."""

    __pydantic_fields__: ClassVar[Dict[str, FieldInfo]]
    """A dictionary of field names and their corresponding FieldInfo objects.
    This replaces `Model.__fields__` from Pydantic V1."""

    __pydantic_extra__: Dict[str, Any] | None = _model_construction.NoInitField(init=False)
    """A dictionary containing extra values, if `extra` is set to 'allow'."""

    __pydantic_fields_set__: set[str] = _model_construction.NoInitField(init=False)
    """The names of fields explicitly set during instantiation."""

    __slots__ = '__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__'

    def __init__(self, /, **data: Any) -> None:
        """Create a new model by parsing and validating input data from keyword arguments."""
        __tracebackhide__ = True
        validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
        if self is not validated_self:
            warnings.warn(
                'A custom validator is returning a value other than `self`.\n'
                "Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\n"
                'See the `model_validator` docs for more details.',
                stacklevel=2,
            )
```

`BaseModel`ì˜ ì£¼ìš” í´ë˜ìŠ¤ ë³€ìˆ˜:
- `model_config`: ëª¨ë¸ ì„¤ì •ì„ ë‹´ëŠ” `ConfigDict` ê°ì²´
- `__pydantic_validator__`: Rustë¡œ ì‘ì„±ëœ `pydantic-core`ì˜ `SchemaValidator`ë¡œ ë§¤ìš° ë¹ ë¥¸ ê²€ì¦ ì„±ëŠ¥ ì œê³µ
- `__pydantic_serializer__`: ëª¨ë¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì§ë ¬í™”í•˜ëŠ” `SchemaSerializer`
- `__pydantic_fields__`: í•„ë“œëª…ê³¼ `FieldInfo` ê°ì²´ì˜ ë”•ì…”ë„ˆë¦¬ (Pydantic V1ì˜ `Model.__fields__`ë¥¼ ëŒ€ì²´)
- `__pydantic_fields_set__`: ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì‹œ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •ëœ í•„ë“œëª… ì§‘í•©

`__init__` ë©”ì„œë“œì—ì„œ `__pydantic_validator__.validate_python()`ì„ í˜¸ì¶œí•˜ì—¬ ì…ë ¥ ë°ì´í„°ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.

**ì£¼ìš” í´ë˜ìŠ¤ ë³€ìˆ˜ í™œìš© ì˜ˆì‹œ**

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    id: int
    name: str = Field(description="ì‚¬ìš©ì ì´ë¦„")
    email: str | None = None
    is_active: bool = True
```

**1. `__pydantic_fields__` - í•„ë“œ ë©”íƒ€ë°ì´í„° ì¡°íšŒ**
```python
# ëª¨ë¸ì— ì •ì˜ëœ ëª¨ë“  í•„ë“œ ì •ë³´ ì¡°íšŒ
for field_name, field_info in User.__pydantic_fields__.items():
    print(f"{field_name}: {field_info.annotation}, required={field_info.is_required()}")

# ì¶œë ¥:
# id: <class 'int'>, required=True
# name: <class 'str'>, required=False
# email: str | None, required=False
# is_active: <class 'bool'>, required=False

# íŠ¹ì • í•„ë“œì˜ description ì¡°íšŒ
print(User.__pydantic_fields__['name'].description)  # "ì‚¬ìš©ì ì´ë¦„"
```

**2. `__pydantic_fields_set__` - ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •ëœ í•„ë“œ í™•ì¸**
```python
# ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•œ ê²½ìš°
user1 = User(id=1, name="John")
print(user1.__pydantic_fields_set__)  # {'id', 'name'}

# ëª…ì‹œì ìœ¼ë¡œ ê¸°ë³¸ê°’ê³¼ ê°™ì€ ê°’ì„ ì„¤ì •í•œ ê²½ìš°
user2 = User(id=1, name="John", is_active=True)
print(user2.__pydantic_fields_set__)  # {'id', 'name', 'is_active'}

# í™œìš©: PATCH ìš”ì²­ì—ì„œ ì‹¤ì œë¡œ ì „ë‹¬ëœ í•„ë“œë§Œ ì—…ë°ì´íŠ¸
def update_user(user_id: int, update_data: User):
    for field in update_data.__pydantic_fields_set__:
        print(f"Updating {field}: {getattr(update_data, field)}")
```

**3. `model_config` - ëª¨ë¸ ì„¤ì • ì¡°íšŒ**
```python
from pydantic import ConfigDict

class StrictUser(BaseModel):
    model_config = ConfigDict(strict=True, frozen=True)

    id: int
    name: str

# ëª¨ë¸ ì„¤ì • ì¡°íšŒ
print(StrictUser.model_config.get('strict'))  # True
print(StrictUser.model_config.get('frozen'))  # True
```

**4. `__pydantic_complete__` - ëª¨ë¸ ë¹Œë“œ ì™„ë£Œ ì—¬ë¶€**
```python
from typing import TYPE_CHECKING

class Post(BaseModel):
    id: int
    author: 'User'  # Forward Reference

# Forward Referenceê°€ í•´ê²°ë˜ê¸° ì „
print(Post.__pydantic_complete__)  # False (ë¯¸ì™„ì„± ìƒíƒœì¼ ìˆ˜ ìˆìŒ)

# model_rebuild()ë¡œ ê°•ì œ ì¬ë¹Œë“œ
Post.model_rebuild()
print(Post.__pydantic_complete__)  # True
```

**FastAPIì—ì„œì˜ í™œìš©**
```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UserCreate(BaseModel):
    name: str
    email: str
    age: int

@app.post("/users")
async def create_user(user: UserCreate):
    # userëŠ” ì´ë¯¸ ê²€ì¦ëœ UserCreate ì¸ìŠ¤í„´ìŠ¤
    return {"message": f"User {user.name} created"}
```

ì˜ëª»ëœ ë°ì´í„°ê°€ ë“¤ì–´ì˜¤ë©´ FastAPIê°€ ìë™ìœ¼ë¡œ 422 ì—ëŸ¬ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤:
```json
// POST /users {"name": "John", "email": "john@example.com", "age": "not_a_number"}
{
    "detail": [
        {
            "type": "int_parsing",
            "loc": ["body", "age"],
            "msg": "Input should be a valid integer, unable to parse string as an integer",
            "input": "not_a_number"
        }
    ]
}
```

<br>

#### 2ï¸âƒ£ íƒ€ì… íŒíŠ¸ ê¸°ë°˜ ìë™ ê²€ì¦

Pydanticì€ Pythonì˜ íƒ€ì… íŒíŠ¸ë¥¼ í™œìš©í•˜ì—¬ ë‹¤ì–‘í•œ íƒ€ì…ì„ ìë™ìœ¼ë¡œ ê²€ì¦í•©ë‹ˆë‹¤.

**ê¸°ë³¸ íƒ€ì…**
```python
from pydantic import BaseModel
from typing import Optional, List, Dict
from datetime import datetime
from enum import Enum

class Status(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"

class Product(BaseModel):
    id: int                          # ì •ìˆ˜
    name: str                        # ë¬¸ìì—´
    price: float                     # ì‹¤ìˆ˜
    is_available: bool               # ë¶ˆë¦¬ì–¸
    tags: List[str]                  # ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸
    metadata: Dict[str, Any]         # ë”•ì…”ë„ˆë¦¬
    created_at: datetime             # ë‚ ì§œ/ì‹œê°„
    status: Status                   # Enum
    description: Optional[str] = None  # ì„ íƒì  í•„ë“œ
```

**ìë™ íƒ€ì… ë³€í™˜ (Coercion)**

Pydanticì€ ê°€ëŠ¥í•œ ê²½ìš° ìë™ìœ¼ë¡œ íƒ€ì…ì„ ë³€í™˜í•©ë‹ˆë‹¤:
```python
class Item(BaseModel):
    id: int
    price: float

# ë¬¸ìì—´ "123"ì´ int 123ìœ¼ë¡œ ìë™ ë³€í™˜
item = Item(id="123", price="99.99")
print(item.id)     # 123 (int)
print(item.price)  # 99.99 (float)
```

ì´ ë™ì‘ì€ `model_config`ì—ì„œ ì œì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
```python
from pydantic import BaseModel, ConfigDict

class StrictItem(BaseModel):
    model_config = ConfigDict(strict=True)  # ì—„ê²© ëª¨ë“œ

    id: int
    price: float

# strict=Trueì¼ ê²½ìš° ë¬¸ìì—´ "123"ì€ ì—ëŸ¬ ë°œìƒ
# StrictItem(id="123", price=99.99)  # ValidationError!
```

<br>

#### 3ï¸âƒ£ Fieldë¥¼ í†µí•œ ìƒì„¸ ê²€ì¦

ë” ì„¸ë°€í•œ ê²€ì¦ì´ í•„ìš”í•œ ê²½ìš° `Field`ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

`ex) Springì˜ @Size, @Min, @Max, @Pattern ì—­í• `

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str = Field(
        min_length=2,           # ìµœì†Œ ê¸¸ì´
        max_length=50,          # ìµœëŒ€ ê¸¸ì´
        description="ì‚¬ìš©ì ì´ë¦„"  # API ë¬¸ì„œì— í‘œì‹œ
    )
    age: int = Field(
        ge=0,                   # >= 0 (greater than or equal)
        le=150,                 # <= 150 (less than or equal)
        description="ë‚˜ì´"
    )
    email: str = Field(
        pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$',  # ì •ê·œì‹ íŒ¨í„´
        description="ì´ë©”ì¼ ì£¼ì†Œ"
    )
    score: float = Field(
        gt=0,                   # > 0 (greater than)
        lt=100,                 # < 100 (less than)
        description="ì ìˆ˜"
    )
```

Springì—ì„œ ë™ì¼í•œ ê²€ì¦:
```java
public class UserDto {
    @Size(min = 2, max = 50)
    private String name;

    @Min(0) @Max(150)
    private int age;

    @Pattern(regexp = "^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$")
    private String email;
}
```

**Fieldì˜ ì£¼ìš” íŒŒë¼ë¯¸í„°**

`pydantic/fields.py`ì—ì„œ Field í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ë©´:
```python
def Field(
    default: Any = PydanticUndefined,
    *,
    default_factory: Callable[[], Any] | None = None,
    alias: str | None = None,
    validation_alias: str | AliasPath | AliasChoices | None = None,
    serialization_alias: str | None = None,
    title: str | None = None,
    description: str | None = None,
    examples: List[Any] | None = None,
    gt: float | None = None,
    ge: float | None = None,
    lt: float | None = None,
    le: float | None = None,
    multiple_of: float | None = None,
    min_length: int | None = None,
    max_length: int | None = None,
    pattern: str | None = None,
    # ...
) -> Any:
```

| íŒŒë¼ë¯¸í„° | ì„¤ëª… | ì˜ˆì‹œ |
|---------|------|------|
| `default` | ê¸°ë³¸ê°’ | `Field(default="unknown")` |
| `default_factory` | ê¸°ë³¸ê°’ íŒ©í† ë¦¬ í•¨ìˆ˜ | `Field(default_factory=list)` |
| `alias` | í•„ë“œ ë³„ì¹­ | `Field(alias="userName")` |
| `gt`, `ge`, `lt`, `le` | ìˆ«ì ë²”ìœ„ ê²€ì¦ | `Field(ge=0, le=100)` |
| `min_length`, `max_length` | ë¬¸ìì—´ ê¸¸ì´ | `Field(min_length=1)` |
| `pattern` | ì •ê·œì‹ íŒ¨í„´ | `Field(pattern=r'^\d+$')` |
| `description` | API ë¬¸ì„œ ì„¤ëª… | `Field(description="ì‚¬ìš©ì ID")` |

**Alias í™œìš©**

API ì‘ë‹µê³¼ ë‚´ë¶€ í•„ë“œëª…ì´ ë‹¤ë¥¼ ë•Œ ìœ ìš©í•©ë‹ˆë‹¤:
```python
from pydantic import BaseModel, Field

class User(BaseModel):
    user_name: str = Field(alias="userName")  # camelCase -> snake_case
    created_at: datetime = Field(alias="createdAt")

    model_config = ConfigDict(populate_by_name=True)

# JSONì—ì„œ camelCaseë¡œ ë°›ì•„ë„ snake_caseë¡œ ì ‘ê·¼ ê°€ëŠ¥
data = {"userName": "john", "createdAt": "2024-01-01T00:00:00"}
user = User(**data)
print(user.user_name)  # "john"
```

<br>

#### 4ï¸âƒ£ Custom Validator

ê¸°ë³¸ ê²€ì¦ìœ¼ë¡œ ë¶€ì¡±í•œ ê²½ìš° ì»¤ìŠ¤í…€ ê²€ì¦ ë¡œì§ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`ex) Springì˜ Custom Validator, @AssertTrue ì—­í• `

**@field_validator - ë‹¨ì¼ í•„ë“œ ê²€ì¦**
```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str
    email: str
    password: str

    @field_validator('name')
    @classmethod
    def name_must_not_be_empty(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('ì´ë¦„ì€ ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤')
        return v.strip()

    @field_validator('email')
    @classmethod
    def email_must_contain_at(cls, v: str) -> str:
        if '@' not in v:
            raise ValueError('ìœ íš¨í•œ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤')
        return v.lower()  # ì†Œë¬¸ìë¡œ ë³€í™˜

    @field_validator('password')
    @classmethod
    def password_strength(cls, v: str) -> str:
        if len(v) < 8:
            raise ValueError('ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤')
        if not any(c.isupper() for c in v):
            raise ValueError('ë¹„ë°€ë²ˆí˜¸ì— ëŒ€ë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤')
        if not any(c.isdigit() for c in v):
            raise ValueError('ë¹„ë°€ë²ˆí˜¸ì— ìˆ«ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤')
        return v
```

**@model_validator - ëª¨ë¸ ì „ì²´ ê²€ì¦**

ì—¬ëŸ¬ í•„ë“œ ê°„ì˜ ê´€ê³„ë¥¼ ê²€ì¦í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤:
```python
from pydantic import BaseModel, model_validator

class DateRange(BaseModel):
    start_date: datetime
    end_date: datetime

    @model_validator(mode='after')
    def check_dates(self) -> 'DateRange':
        if self.start_date >= self.end_date:
            raise ValueError('ì‹œì‘ì¼ì€ ì¢…ë£Œì¼ë³´ë‹¤ ì´ì „ì´ì–´ì•¼ í•©ë‹ˆë‹¤')
        return self

class UserCreate(BaseModel):
    password: str
    password_confirm: str

    @model_validator(mode='after')
    def check_passwords_match(self) -> 'UserCreate':
        if self.password != self.password_confirm:
            raise ValueError('ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤')
        return self
```

**mode ì˜µì…˜**
- `mode='before'`: íƒ€ì… ë³€í™˜ ì „ì— ì‹¤í–‰ (raw ë°ì´í„° ì ‘ê·¼)
- `mode='after'`: íƒ€ì… ë³€í™˜ í›„ì— ì‹¤í–‰ (ê²€ì¦ëœ ë°ì´í„° ì ‘ê·¼)

```python
from pydantic import BaseModel, model_validator
from typing import Any

class FlexibleModel(BaseModel):
    data: dict

    @model_validator(mode='before')
    @classmethod
    def convert_string_to_dict(cls, values: Any) -> Any:
        # JSON ë¬¸ìì—´ì„ dictë¡œ ë³€í™˜
        if isinstance(values.get('data'), str):
            import json
            values['data'] = json.loads(values['data'])
        return values
```

<br>

#### 5ï¸âƒ£ Nested Model (ì¤‘ì²© ëª¨ë¸)

ë³µì¡í•œ ë°ì´í„° êµ¬ì¡°ë¥¼ í‘œí˜„í•  ë•Œ ëª¨ë¸ì„ ì¤‘ì²©í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.

`ex) Springì˜ ì¤‘ì²© DTO êµ¬ì¡°`

```python
from pydantic import BaseModel
from typing import List, Optional

class Address(BaseModel):
    street: str
    city: str
    zip_code: str
    country: str = "Korea"

class Company(BaseModel):
    name: str
    address: Address  # ì¤‘ì²© ëª¨ë¸

class User(BaseModel):
    id: int
    name: str
    email: str
    address: Optional[Address] = None  # ì„ íƒì  ì¤‘ì²© ëª¨ë¸
    company: Optional[Company] = None
    friends: List['User'] = []  # ìê¸° ì°¸ì¡° (Forward Reference)
```

**ì‚¬ìš© ì˜ˆì‹œ**
```python
# ì¤‘ì²©ëœ JSON ë°ì´í„°
data = {
    "id": 1,
    "name": "John",
    "email": "john@example.com",
    "address": {
        "street": "123 Main St",
        "city": "Seoul",
        "zip_code": "12345"
    },
    "company": {
        "name": "Tech Corp",
        "address": {
            "street": "456 Business Ave",
            "city": "Seoul",
            "zip_code": "67890"
        }
    }
}

user = User(**data)
print(user.address.city)          # "Seoul"
print(user.company.address.city)  # "Seoul"
```

**FastAPIì—ì„œ ì¤‘ì²© ëª¨ë¸ í™œìš©**
```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class OrderItem(BaseModel):
    product_id: int
    quantity: int
    price: float

class Order(BaseModel):
    order_id: int
    customer_name: str
    items: List[OrderItem]

    @property
    def total_price(self) -> float:
        return sum(item.price * item.quantity for item in self.items)

@app.post("/orders")
async def create_order(order: Order):
    return {
        "order_id": order.order_id,
        "total_price": order.total_price,
        "item_count": len(order.items)
    }
```

ìš”ì²­ ì˜ˆì‹œ:
```json
{
    "order_id": 1,
    "customer_name": "John",
    "items": [
        {"product_id": 101, "quantity": 2, "price": 10.0},
        {"product_id": 102, "quantity": 1, "price": 25.0}
    ]
}
```

<br>

#### 6ï¸âƒ£ ì§ë ¬í™”ì™€ ì—­ì§ë ¬í™”

Pydantic ëª¨ë¸ì€ ë‹¤ì–‘í•œ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ëª¨ë¸ â†’ dict/JSON**
```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str
    password: str  # ë¯¼ê° ì •ë³´

user = User(id=1, name="John", email="john@example.com", password="secret123")

# dictë¡œ ë³€í™˜
user_dict = user.model_dump()
# {'id': 1, 'name': 'John', 'email': 'john@example.com', 'password': 'secret123'}

# íŠ¹ì • í•„ë“œ ì œì™¸
user_dict = user.model_dump(exclude={'password'})
# {'id': 1, 'name': 'John', 'email': 'john@example.com'}

# íŠ¹ì • í•„ë“œë§Œ í¬í•¨
user_dict = user.model_dump(include={'id', 'name'})
# {'id': 1, 'name': 'John'}

# JSON ë¬¸ìì—´ë¡œ ë³€í™˜
user_json = user.model_dump_json()
# '{"id":1,"name":"John","email":"john@example.com","password":"secret123"}'
```

**dict/JSON â†’ ëª¨ë¸**
```python
# dictì—ì„œ ìƒì„±
user = User(**{"id": 1, "name": "John", "email": "john@example.com", "password": "secret"})

# JSON ë¬¸ìì—´ì—ì„œ ìƒì„±
user = User.model_validate_json('{"id": 1, "name": "John", "email": "john@example.com", "password": "secret"}')
```

**ì‘ë‹µ ëª¨ë¸ ë¶„ë¦¬ íŒ¨í„´**

ë³´ì•ˆì„ ìœ„í•´ ìš”ì²­ê³¼ ì‘ë‹µ ëª¨ë¸ì„ ë¶„ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤:
```python
from pydantic import BaseModel
from typing import Optional

# ìš”ì²­ìš© ëª¨ë¸
class UserCreate(BaseModel):
    name: str
    email: str
    password: str

# ì‘ë‹µìš© ëª¨ë¸ (ë¹„ë°€ë²ˆí˜¸ ì œì™¸)
class UserResponse(BaseModel):
    id: int
    name: str
    email: str

# DB ëª¨ë¸ (ë‚´ë¶€ìš©)
class UserInDB(BaseModel):
    id: int
    name: str
    email: str
    hashed_password: str

@app.post("/users", response_model=UserResponse)
async def create_user(user: UserCreate):
    # passwordë¥¼ í•´ì‹±í•˜ì—¬ ì €ì¥
    hashed_password = hash_password(user.password)

    # DBì— ì €ì¥ (ê°€ì •)
    db_user = UserInDB(
        id=1,
        name=user.name,
        email=user.email,
        hashed_password=hashed_password
    )

    # response_model=UserResponseì´ë¯€ë¡œ password ê´€ë ¨ í•„ë“œëŠ” ìë™ ì œì™¸
    return db_user
```

<br>

#### 7ï¸âƒ£ ì‹¤ì „ í™œìš© íŒ

**Configë¥¼ í†µí•œ ëª¨ë¸ ì„¤ì •**
```python
from pydantic import BaseModel, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(
        str_strip_whitespace=True,      # ë¬¸ìì—´ ì•ë’¤ ê³µë°± ì œê±°
        str_min_length=1,               # ëª¨ë“  ë¬¸ìì—´ ìµœì†Œ ê¸¸ì´
        frozen=True,                    # ë¶ˆë³€ ê°ì²´ë¡œ ë§Œë“¤ê¸° (immutable)
        extra='forbid',                 # ì •ì˜ë˜ì§€ ì•Šì€ í•„ë“œ ê¸ˆì§€
        use_enum_values=True,           # Enum ê°’ ìë™ ë³€í™˜
        validate_assignment=True,       # í• ë‹¹ ì‹œì—ë„ ê²€ì¦
    )

    name: str
    email: str
```

**ORM ëª¨ë“œ (from_attributes)**

SQLAlchemy ë“± ORM ê°ì²´ë¥¼ Pydantic ëª¨ë¸ë¡œ ë³€í™˜í•  ë•Œ:
```python
from pydantic import BaseModel, ConfigDict

class UserResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    name: str
    email: str

# SQLAlchemy ëª¨ë¸ì—ì„œ ì§ì ‘ ë³€í™˜
db_user = session.query(UserModel).first()
user_response = UserResponse.model_validate(db_user)
```

**Generic Model**
```python
from pydantic import BaseModel
from typing import TypeVar, Generic, List

T = TypeVar('T')

class PaginatedResponse(BaseModel, Generic[T]):
    items: List[T]
    total: int
    page: int
    size: int

    @property
    def pages(self) -> int:
        return (self.total + self.size - 1) // self.size

# ì‚¬ìš©
class User(BaseModel):
    id: int
    name: str

response = PaginatedResponse[User](
    items=[User(id=1, name="John"), User(id=2, name="Jane")],
    total=100,
    page=1,
    size=10
)
```

ì´ì²˜ëŸ¼ Pydanticì€ FastAPIì—ì„œ ë°ì´í„° ê²€ì¦, ì§ë ¬í™”, API ë¬¸ì„œí™”ë¥¼ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•´ì£¼ëŠ” í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤. Springì˜ Bean Validationê³¼ DTO íŒ¨í„´ì„ Python íƒ€ì… íŒíŠ¸ë§Œìœ¼ë¡œ ê°„ê²°í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì´ ê°€ì¥ í° ì¥ì ì…ë‹ˆë‹¤.






